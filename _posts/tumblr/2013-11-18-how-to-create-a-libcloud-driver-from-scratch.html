---
layout: post
title: 'How to create a libcloud driver from scratch: the NephoScale case'
date: '2013-11-18T16:19:00+02:00'
tags:
- open source
- python
- libcloud
tumblr_url: https://blog.mist.io/post/67366170830/how-to-create-a-libcloud-driver-from-scratch
---
<p>The use of Web APIs for communicating with cloud providers has been increasing over the last few years and every computing and web services provider is expected to maintain a well documented API for their clients. It enables developers, system administrators and engineers to  automate tasks and assists in the deployment of servers and services; and as multi-cloud setups become the norm and cloud management tools a necessity, a well documented API significantly enhances the user experience.</p>
<p>As one would expect, there are many tools in different programming languages that facilitate the communication with each cloud API.  On the Python world, <a href="http://libcloud.apache.org" title="Libcloud">libcloud</a> is the de facto library to communicate with one or more cloud providers. It abstracts away differences among multiple cloud provider APIs and provides a unified way to manage cloud resources.</p>
<p>Mist.io makes heavy use of libcloud in order to support a wide range of providers in a unified interface. <a href="https://mist.io/" title="mist.io homepage"><strong>You can try it out for yourselves by logging in mist.io.</strong></a></p>
<p><img alt="image" src="https://66.media.tumblr.com/78048ae4fe732206bd7f21714744f709/tumblr_inline_mwmhax11ie1rgqrs8.png"/></p>
<p>Libcloud was initially developed by the awesome <strong>CloudKick</strong> team. Today it is an Apache foundation project. It has a healthy community, with lots of contributors, <a href="https://ci.apache.org/projects/libcloud/docs/">updated documentation</a>, mailing lists, a <a href="https://issues.apache.org/jira/browse/LIBCLOUD">ticketing system</a>, a continuous integration platform and an established <a href="http://libcloud.apache.org/whos-using.html" title="who's using libcloud">user base</a>.</p>
<p>Libcloud allows users to manage four different cloud resources: Cloud Servers, Cloud Storage, Load Balancers as a Service and DNS as a Service. Cloud Servers is the oldest and more mature part of the library and currently supports more than 26 providers.</p>
<p>Many cloud providers eg Amazon, Rackspace, Linode, DigitalOcean etc, are already supported by libcloud. In this post we want to illustrate how easy it is to add support for new providers, by documenting the steps we followed to add support for a cutting edge US-based cloud provider <a href="http://nephoscale.com" title="NephoScale">NephoScale.</a></p>
<p><img alt="image" src="https://66.media.tumblr.com/85eb1597543ecb9d11c93da22a757cc0/tumblr_inline_mwmhoc1JAy1rgqrs8.png"/></p>

<p><strong>What should we implement on our compute driver</strong></p>
<p>Our goal is to create a compute driver that will provide the most common sever management actions. Actions that are universally supported by libcloud for all the cloud providers:</p>
<ul><li>list_nodes: provide a list with our nodes, including information such as public/private ip addresses, node state -running, rebooting, stopped etc- and some extra metadata such as the image, location etc</li>
<li>list_images: list all the images the provider supports for faster node creation</li>
<li>list_sizes: list different plans, providing data such as CPU, ram and disk size. Some providers include the price of each size plan</li>
<li>list_locations: Most cloud providers allow us to specify the different zone where we can deploy nodes</li>
</ul><p>and the following node actions:</p>
<ul><li>create_node: create a node specifying it&rsquo;s size, image, name and location</li>
<li>deploy_node: create a node and deploy a public ssh key for server access, and optionally run a deploy script after the node is initialized and can be accessible</li>
<li>reboot_node/shut down_node</li>
<li>start_node/stop_node: start a stopped node, or stop a started one</li>
<li>destroy_node: Delete the node</li>
</ul><p>We will implement the above for the NephoScale driver, plus some extra functions that will allow us to create, list and delete keypairs. Keypairs in NephoScale can be ssh or password keys, for server or console access. Digital Ocean also allows the listing/creation/deletion of keys through it&rsquo;s API, while other cloud providers do not offer that functionality. Other examples of provider specific functionality include tagging, where only a few cloud providers (eg AWS, Rackspace) provide. In this example and in order to be as generic as possible, we will target functionality that is available for most -if not all- cloud providers.</p>
<p><strong>Getting started with the compute driver</strong></p>
<p>We&rsquo;ll need access to our provider API. In this scenario, the <a href="http://docs.nephoscale.com/#!/reference/nephos">Nephoscale API</a>.</p>
<p>We will use the Digital Ocean driver as a template as it is one of the most recent, well written and up-to-date drivers. There is an effort by libcloud to standardize the basic functionality for all the compute drivers, and update the oldest ones. It is also very important when cloud providers contribute code or review the drivers created for them in libcloud, or even better maintain them as their API changes. </p>
<p>Compute drivers are located on libcloud/compute/drivers and they all inherit from the base compute driver NodeDriver on libcloud/compute/base.py. The driver is well documented and we can learn a lot from reading the comments and of course the code.</p>
<p><strong>Add the driver on types.py and providers.py<br/></strong></p>
<p>We&rsquo;ll start by adding our provider on the DRIVERS dict on libcloud/compute/providers.py and on Provider class on libcloud/compute/types.py. It&rsquo;s pretty straightforward as we can see from the existing drivers.</p>
<p><strong>Create driver file and start writing the code</strong><br/>On libcloud/compute/drivers/ we create a file with the name of our provider: nephoscale.py in our case.</p>
<p>After the initial imports that we copy from the Digital Ocean driver, we specify the API endpoint of our cloud provider</p>
<pre>API_HOST = 'api.nephoscale.com'</pre>
<p>and a dict with the states that the nodes can have. This differs from provider to provider, with some providers having just a few states -running, stopped - and others having intermediates ones -e.g. rebooting, shutting down etc.</p>
<pre>NODE_STATE_MAP = {<br/>    'on': NodeState.RUNNING,<br/>    'off': NodeState.UNKNOWN,<br/>    'unknown': NodeState.UNKNOWN,<br/>}</pre>
<p><strong>Writing the NephoscaleNodeDriver<br/></strong></p>
<p>We then need to create a NodeDriver based driver</p>
<pre>class NephoscaleNodeDriver(NodeDriver):<br/>    """Nephoscale node driver class"""<br/><br/>    type = Provider.NEPHOSCALE<br/>    api_name = 'nephoscale'<br/>    name = 'NephoScale'<br/>    website = 'http://www.nephoscale.com'<br/>    connectionCls = NephoscaleConnection<br/>    features = {'create_node': ['ssh_key']}<br/><br/>    def list_locations(self):<br/>    ...</pre>
<p>Here we specify the type (same as on libcloud/compute/types.py), the connection class (NephoscaleConnection) and a features dict with the way deploy_node will try to authenticate to the created node after create_node has run . Inside the NephoscaleNodeDriver is where all our functions will live. We&rsquo;ll write all functions we want to implement there, list_images, list_nodes, reboot_node etc. To keep consistency, we make sure that list_nodes returns a list of Node objects, list_images a list of NodeImage objects, list_sizes a list of NodeSize objects and list_locations a list of NodeLocation objects.</p>
<p><strong>Writing the Connection class</strong></p>
<p>NephoscaleConnection is the Connection class that will handle connection, authentication and send the request to the NephoScale API endpoint. All drivers implement a Connection class that is responsible for sending the request data, adding HTTP headers or params and also encoding the request body.The API host endpoint is specified there, along with the HTTP headers or params that are used to authenticate for each provider. <span class="st"></span></p>
<p><span id="docs-internal-guid-29617e1f-76c7-01a3-b903-3293348bb1c6">NephoScale API calls require HTTP Basic Authentication with the user/password base64 encoded on every request, so we&rsquo;ll add it to add_default_params. </span></p>
<pre>class NephoscaleConnection(ConnectionUserAndKey):<br/>    """Nephoscale connection class<br/><br/>    Authenticates to the API through Basic Authentication<br/>    with username/password<br/><br/>    """<br/>    host = API_HOST<br/>    responseCls = NephoscaleResponse<br/><br/>    def add_default_headers(self, headers):       <br/>        user_b64 = base64.b64encode(b('%s:%s' % (self.user_id, self.key)))<br/>        headers['Authorization'] = 'Basic %s' % (user_b64.decode('utf-8'))<br/>        return headers<br/><br/></pre>
<p>Other providers handle authentication with requiring the params on each request -API key, password, secret etc.</p>
<p>DigitalOcean for example requests the client ID and API key on each request, and we pass it with add_default_params</p>
<pre>class DigitalOceanConnection(ConnectionUserAndKey):<br/>    ...<br/><br/>    def add_default_params(self, params):<br/>        params['client_id'] = self.user_id<br/>        params['api_key'] = self.key<br/>        return params</pre>
<p><span>Inside our Connection class we can override encode_data method, so that it encodes data</span> as requested. For example we can set it to encode data with json.encode, if the API endpoint expects json encoded data.  </p>
<p>The Connection class that gets overridden on our driver lives in libcloud/common/base.py.  <br/></p>
<p><strong>Writing the Response class<br/></strong></p>
<p>All drivers also need a response class that handles responses of the API endpoint, parses body and returns Exceptions or the actual return content.  Response classes for the libcloud drivers derive from JsonResponse or XMLRPCResponse, depending on the response type of the cloud provider -Json or XML. Both derive from Response class that lives in libcloud/common/base.py. We want to make sure here that in the case of errors we throw the correct exceptions - e.g. InvalidCredsError for failed authentication.</p>
<pre>class NephoscaleResponse(JsonResponse):<br/>    """Nephoscale API Response"""<br/><br/>    def parse_error(self):<br/>        if self.status == httplib.UNAUTHORIZED:<br/>            raise InvalidCredsError('Authorization Failed')<br/>        if self.status == httplib.NOT_FOUND:<br/>            raise Exception("The resource you are looking for is not found.")<br/><br/>        return self.body<br/><br/></pre>
<p><strong>Notes on create_node and deploy_node</strong></p>
<p>Most of the drivers of libcloud implement create_node to return a Node object, of the newly created host. Function deploy_node is not overridden , but instead gets called from the NodeDriver, since it does a lot of things that need not be rewritten, such as checks that the node public ip is up, that the machine can be accessible, that it can authenticate via password or ssh key, and optionally runs a deploy script.</p>
<p>The default behaviour of create_node is to send the request for the node to be created, and get a response with the created node id. Most cloud providers we have used reply with the ID of the created node, along with information about the state of the node, public ip etc. NephoScale does not respond with an ID once it receives the request for a node to be created, but instead replies with a status ID that is not very helpful. So as soon as we send the request and receive a valid response, we&rsquo;ll be waiting for a bit and try to get the machine information by requesting list_nodes and checking if the machine has appeared. When we have the machine Node, we return create_node. In this way the behaviour of create_node stays consistent with the other drivers and deploy_node works as expected, out of the box.</p>
<p>Once again, reading the comments of NodeDriver on libcloud/compute/base.py for deploy_node and create_node functions will help us implement create_node and make sure deploy_node will work.</p>
<p><strong>Keep consistency, hard code things when necessary<br/></strong></p>
<p>One of the cool things with libcloud is that it standardizes things. It enforces the use of basic entities -nodes, sizes, images, locations- for all cloud providers it supports.</p>
<p><a href="http://softlayer.com">SoftLayer</a> for example does not provide a size entity through it&rsquo;s API, but rather expects that we specify CPU, RAM and disk size when we create a node. The way libcloud driver is implemented, one can either pass these manually, or simply select one of the sizes provided by list_sizes.</p>
<p>Ideally all size/image/location related data should be fetched by asking the provider. When this is not possible, for example when the provider does not implement a request, we need to hard code these settings. For example the pricing info for some of the providers isn&rsquo;t returned while asking for the sizes (list_sizes) and thus is hard coded on libcloud/data/pricing.json. Or the info regarding sizes for AWS is not available through an API call. The obvious disadvantage with hard coding things is that they have to be maintained to reflect the current status of the provider&rsquo;s API.</p>
<p><strong>Working with our driver</strong></p>
<p>While writing the driver, it is always good to test it:</p>
<pre>user@user:~/dev/libcloud$ python<br/>&gt;&gt;&gt; from libcloud.compute.types import Provider<br/>&gt;&gt;&gt; from libcloud.compute.providers import get_driver<br/>&gt;&gt;&gt; driver = get_driver(Provider.NEPHOSCALE)<br/>&gt;&gt;&gt; conn = driver('user','correct_password')<br/>&gt;&gt;&gt; conn.list_nodes()<br/>[&lt;Node: uuid=e20bdbf7ef6890645f5b217e0bd2b5912b969cc1, <br/>name=nepho-7, state=0, public_ips=['198.89.109.116'], <br/>provider=NephoScale ...&gt;]</pre>
<p>We can use the connection class for GET or POST requests according to the API, for testing and debugging issues. E.g to implement the list_locations for NephoScale, we need to see what the response is after requesting the locations (via <a href="https://api.nephoscale.com/datacenter/zone/">https://api.nephoscale.com/datacenter/zone/</a>)</p>
<pre>&gt;&gt;&gt; conn.connection.request('/datacenter/zone/').object<br/>{'success': True,<br/>'total_count': 2, <br/>'subcode': 0,<br/>'message': 'Your request was processed successfully.',<br/>'data': [<br/>  {'datacenter': {<br/>      'id': 1,<br/>      'airport_code': 'SJC', <br/>      'name': 'SJC-1',<br/>      'uri': 'https://api.nephoscale.com/datacenter/1/'},<br/>   'uri': 'https://api.nephoscale.com/datacenter/zone/86945/',<br/>   'name': 'SJC-1',<br/>   'id': 86945},<br/>  {'datacenter': {<br/>     'id': 3, <br/>     'airport_code': 'RIC', <br/>     'name': 'RIC-1',<br/>     'uri': 'https://api.nephoscale.com/datacenter/3/'},<br/>   'uri': 'https://api.nephoscale.com/datacenter/zone/87729/',<br/>   'name': 'RIC-1', <br/>   'id': 87729}],<br/>'response': 200}<br/><br/></pre>
<p><strong>Contributing to libcloud</strong></p>
<p>Having created the compute driver for our cloud provider and having tested it&rsquo;s functionality, it is time to commit it to libcloud. In this case we need to write tests -ideally for all functionality, add some fixtures and make sure the tests pass. Libcloud contains unit tests for nearly everything and enforces testing for new functionality. Testing on libcloud deserves another post by itself.</p>
<p>Until then, details for contributing can be found can be found <a href="https://libcloud.readthedocs.org/en/latest/development.html#contributing" title="contributing to libcloud">here</a>.The process involves creating a ticket to libcloud’s<a href="https://issues.apache.org/jira/browse/LIBCLOUD"> JIRA issue tracker</a> and opening a pull request to libcloud’s<a href="http://github.com/apache/libcloud"> github repository</a>. The code will be reviewed and most probably comments and suggestions will arise.</p>
<p>So have fun developing your driver!</p>
<p><a href="https://mist.io/" title="mist.io homepage"><strong>To check this driver in action log in to mist.io</strong></a></p>

<p><em>Special thanks to <a href="http://www.tomaz.me/" title="tomaz blog">Tomaz</a>, maintainer of liblcoud and it&rsquo;s bigger laborer of love, for proof reading this post.</em></p>

<p></p>
